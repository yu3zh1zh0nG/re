# 正则表达式
### 1.动机
1. 文本处理已经成为计算机的常见工作之一
2. 对文本内容的搜索，定位，提取是逻辑比较复杂的
3. 为了快速方便的解决上述问题。产生了正则表达式技术


### 2.定义
- 即文本的高级匹配模式，提供搜索，替代等功能。
- 本质是由一系列特殊符号和字符组成的字串，这个字串即是正则表达式。
- 正则表达式描述了字符和字符的重复行为，可以匹配一类特征的字符串


### 3.目标
1. 熟练掌握正则表达式符号
2. 能够编写一定程度的正则表达式和理解较难的正则
3. 能够使用python操作正则表达式


### 4.特点
1. 文编进行检索修改的文本操作
2. 支持语言众多
3. 使用灵活多样


## Python--》re模块：处理正则表达式
##### 函数：
1. re.findall(pattern,string)
    - 功能：使用正则表达式匹配字符串
    - 参数：
        - pattern： 正则表达式
        - string： 目标字符串
    - 返回值：返回一个列表，列表中匹配到的内容

##### 元字符（即正则表达式中有特殊含义的符号）
1. 普通字符
    - 元字符：abc
    - 匹配规则：匹配相应的字符
2. 或
    - 元字符：|
    - 匹配规则：匹配| 两边任意正则表达式的内容                                       
    - 示例
    ```
    In [7]: re.findall('ab|cd','ablalacd')
    Out[7]: ['ab', 'cd']
    #匹配ab或bc时，当遇到abc时只匹配到ab
    In [8]: re.findall('ab|bc','abcalacd')
    Out[8]: ['ab']
    ```
3. 匹配单一字符
    - 元字符：. 
    - 匹配规则：匹配除换行外的任意字符
    - 示例
    ```
    In [9]: re.findall('f.o','fao is not foo')
    Out[9]: ['fao', 'foo']
    ```
4. 匹配开始位置
    - 元字符：^
    - 匹配规则：匹配字符串的开头位置
    - 示例
    ```
    In [10]: re.findall('^hello','helloworld')
    Out[10]: ['hello']
    
    In [11]: re.findall('^hello','lalahelloworld')
    Out[11]: []
    ```


5. 匹配结束位置
    - 元字符：$
    - 匹配规则：匹配目标字符串的结束位置
    - 示例：
    ```
    In [17]: re.findall('py$','hello.py')
    Out[17]: ['py']
    
    In [18]: re.findall('py$','python')
    Out[18]: []
    ```


6. 匹配重复
    - 元字符：*
    - 匹配前面的正则表达式0次或者多次
    - 示例：
    ```
    此时o*相当于一个整体，代表o出现0次或者多次
    In [19]: re.findall('fo*','f la fo la foooo')
    Out[19]: ['f', 'fo', 'foooo']
    ```


7. 匹配重复
    - 元字符：+
    - 匹配前面的正则表达式1次或者多次
    - 示例：
    ```
    In [20]: re.findall('fo+','f la fo la foooo')
    Out[20]: ['fo', 'foooo']
    #任意字符重复一次或者多次
    In [24]: re.findall('.+py','hello.py la')
    Out[24]: ['hello.py']
    ```


8. 匹配重复 
    - 元字符：？
    - 匹配规则：匹配前面的正则表达式0次或1次
    - 示例：
    ```
    In [25]: re.findall('fo?','f la fo la foooo')
    Out[25]: ['f', 'fo', 'fo']
    ```


9. 匹配重复
    - 元字符：{n}
    - 匹配规则：匹配指定的重复次数
    - 示例：
    ```
    In [27]: re.findall('fo{2}','f la fo la foooo')
    Out[27]: ['foo']
    ```


10. 匹配重复
    - 元字符：{m,n}
    - 匹配规则：匹配前面的正则表达式m~n次
    - 示例：
    ```
    In [28]: re.findall('fo{2,4}','f la fo la foooo')
    Out[28]: ['foooo']
    ```


11. 匹配字符集合
    - 元字符：[字符集]
    - 匹配规则：匹配括号内的任意一个字符
    - 示例：
    ```
    In [33]: re.findall('[a-p,1-6]','beozw 58')
    Out[33]: ['b', 'e', 'o', '5']
    
    In [35]: re.findall('[a-p1-6A-Z]','beozwQWER58')
    Out[35]: ['b', 'e', 'o', 'Q', 'W', 'E', 'R', '5']
    
    In [36]: re.findall('[0-9a-zA-Z]+','hello WORLD 123')
    Out[36]: ['hello', 'WORLD', '123']
    ```


12. 匹配字符集和 
    - 元字符：[^字符集]
    - 匹配规则：匹配除了括号中字符集的任意一个字符
    - 示例：
    ```
    In [38]: re.findall('[^0-9a-z]+','hello WORLD 123')
    Out[38]: [' WORLD ']
    ```


13. 匹配任意（非）数字字符
    - 元字符:\d    \D
    - 匹配规则：\d 匹配任意数字字符[0-9] ；\D 匹配任意非数字字符[^0-9]
    - 示例：
    ```
    In [43]: re.findall('1\d{10}','13135673615')
    Out[43]: ['13135673615']
    
    In [44]: re.findall('\D+','yzz de iph:13135673615')
    Out[44]: ['yzz de iph:']
    ```


14. 匹配（非）普通字符（数字字母下划线为普通字符）
    - 元字符： \w   \W
    - 匹配规则： \w匹配普通字符[_0-9a-zA-Z]，汉字也是普通字符；  \W非普通字符[^_0-9a-zA-Z]
    - **注**：\w可以匹配普通的utf-8字符（比如汉字）
    - 示例：
    ```
    In [48]: re.findall('\w+','hello$WORLD')
    Out[48]: ['hello', 'WORLD']
    
    In [49]: re.findall('\W+','hello$WORLD')
    Out[49]: ['$']
    
    In [50]: re.findall('\w+','hello$你好WORLD')
    Out[50]: ['hello', '你好WORLD']
    ```
    
15. 匹配（非）空字符：空格，\r ,\n,\t
    - 元字符：\s； \S
    - 匹配规则：\s空字符； \S非空字符
    - 示例：
    ```
    In [52]: re.findall('\s','hello WORLD\t yzz\n')
    Out[52]: [' ', '\t', ' ', '\n']
    ```
    
    
16. 匹配起止位置
    - 元字符：\A;\Z
    - 匹配规则：\A 匹配开始位置  ， \Z 匹配终止位置
    - **注** ：绝对匹配：使用开头和结尾位置的元字符将正则表达式放在其中，则目标字符串仅有正则匹配内容时才能匹配上
    - 示例：
    ```
    In [54]: re.findall('\Ahello\Z','hello')
    Out[54]: ['hello']
    ```

17. 匹配（非）单词边界位置
    - 普通字符和非普通字符的交界处为单词边界
    - 元字符：\b;\B
    - 匹配规则：\b:单词边界；  \B:非单词边界
    - 示例：
    ```
    In [57]: re.findall('is','This is a test')
    Out[57]: ['is', 'is']
    
    In [59]: re.findall('\bis','This is a test')
    Out[59]: []
    
    In [60]: re.findall(r'\bis','This is a test')
    Out[60]: ['is']
    
    In [62]: re.findall(r'is\b','This is a test')
    Out[62]: ['is', 'is']

    In [61]: re.findall(r'\Bis','This is a test')
    Out[61]: ['is']

    In [64]: re.findall(r'is\B','This is a test')
    Out[64]: []
    ```
    
    
### 总结：
1. 匹配单个字符:
    ```
    a   .   \d  \D  \w  \W  \s  \S  [...]   [^..]
    ```
2. 匹配重复性:
    ```
    *   +   ?   {n} {m,n} 
    ```
3. 匹配位置：
    ```
    ^   $   \A  \Z  \b  \B
    ```
4. 其他：
    ```
    |   ()  \
    ```
5. 正则表达式中的转义 
    ```
    .   *   ?   $   []  {}  {}  ^   \
    ```
### raw原生字符串
- 概念：
    - 原生字符串，字符串内容就是本身，你进行任何转义
- 用法：
    - 在字符串前加r  


### 贪婪与非贪婪
1. 贪婪模式：   
    - 正则表达式的重复匹配默认总是尽可能的向后匹配内容
    ```
    *   +   ?   {m,n}
    ```

2. 非贪婪模式：
    - 尽可能少的匹配内容
    ```
    贪婪   --------》  非贪婪
            加问号
    *?  +?  ??  {m,n}?
    ```
- 示例：
```
In [79]: re.findall('fo{2,5}','fooooooo')
Out[79]: ['fooooo']

In [80]: re.findall('fo{2,5}?','fooooooo')
Out[80]: ['foo']

```




### 正则表达式分组
- 概念：
    - 使用()可以为一个正则表达式建立子组，子组并不会影响正则表达式的整体匹配内容，子组可以看做是一个内部的整体部分
- 子组的作用：
    1. 子组可以改变真个表达式的重复行为
    2. 子组在某些操作中可以被单独提取出来

    - 示例：
    ```
    (ab)重复
    In [82]: re.search(r'(ab)+','ababababab').group()
    Out[82]: 'ababababab'
    
    In [93]: re.search(r'(ab)+','ababababab').group(1)
    Out[93]: 'ab'

    b重复
    In [84]: re.search(r'ab+','ababababab').group()
    Out[84]: 'ab'
    ```
- 子组的使用注意事项
    - 一个正则表达式中可以有多个子组 ；从外到内从左到右分别为第一第二第三...子组
    - 子组不存在交叉的情况




- 捕获组合非捕获组（即命名组和非命名组）
    - 捕获组格式：
        - (?P<name>pattern)
    1. 很多编程接口可以通过名字直接获取子组匹配内容
    2. 命名组可以被重复调用
        - 调用的方法：(?P=name)
    - 示例：
    ```
    In [103]: re.search(r'(?P<dog>ab)cdef(?P=dog)','abcdefab').group()
    Out[103]: 'abcdefab'

    ```


### 正则表达式使用要求
1. 唯一性
    - 正则表达式只能匹配目标类别字符串。而不能匹配其他内容
2. 准确性
    - 尽可能全面的考虑目标类别的字符串特征，做到不遗漏






































